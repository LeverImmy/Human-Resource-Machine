# 《程序设计基础》 大作业报告

**目录**

- [Human Resource Machine](#)
    - [设计思路](#设计思路)
    - [工程结构](#工程结构)
    - [具体实现](#具体实现)
    - [界面设计](#界面设计)
    - [游戏测试](#游戏测试)
    - [自由创新关卡](#自由创新关卡)
    - [小组分工](#小组分工)

## 设计思路

我们选择使用 Qt Creator 进行大作业程序的编写。它提供了一条设计图形界面并将其与程序整合起来的简单途径。

在设计思路上，我们主要使用队列来模拟传送带，并使用向量来存储空地的状态。具体而言，我们在`qIn`与`qOut`两个队列中存储了当前关卡的输入序列与目标序列，并用`qAns`队列来存储当前的输出序列。在指令执行完成后，程序将比对`qAns`与`qOut`，并以此判断关卡是否通过。

## 工程结构

工程结构如下表所示。
```c++
- HumanResourceMachine
	- Header Files
		- widget.h
	- Source Files
		- main.cpp
		- widget.cpp
			- void on_backButton1_clicked()
			- void on_backButton2_clicked()
			- void on_backButton3_clicked()
			- void on_startButton_clicked()
			- void on_aboutButton_clicked()
			- void on_exitButton_clicked()
			- void on_volumnHorizontalSilder_valueChanged()
			- void on_levelButton1_clicked()
			- void on_levelButton2_clicked()
			- void on_levelButton3_clicked()
			- void on_levelButton4_clicked()
			- void on_confirmNextStepButton_clicked()
			- void drawStatus()
			- void setUpBackground()
			- void printSuccessMessage()
			- void printFailMessage()
			- void printErrorMessage()
			- bool checkResult()
			- bool valid(QString)
			- void renderLevelButton(int)
	- Resources.qrc
	- widget.ui
```

- `widget.h`
- `main.cpp`
- `widget.cpp`  中实现了程序的大部分功能。
	- `on_backButton1_clicked()`、`on_backButton2_clicked()`、`on_backButton3_clicked()`在按下不同页面的`返回`键时被调用。它们将程序的界面设置为上一级页面。
	- `on_startButton_clicked()`在按下`开始游戏`键时被调用。它将试图读取储存于程序可执行文件所在目录中的存档`userdata.txt`，并根据其解锁可游玩的关卡。随后，它将程序界面设置为关卡选择页面。
	- `on_aboutButton_clicked()`在按下`设置`键时被调用。它将程序的界面设置为设置页面。
	- `on_exitButton_clicked()`在按下`退出游戏`键时被调用。它将目前已经通关的关卡编号写入`userdata.txt`中，随后关闭程序。
	- `on_volumnHorizontalSlider_valueChanged()`在设置界面的音量滑块移动时被调用。它将程序背景音乐的音量设置为与滑块位置相对应的音量。
	- `on_levelButton1_clicked()`、`on_levelButton2_clicked()`、`on_levelButton3_clicked()`分别在按下`第一关`、`第二关`、`第三关`键时被调用。它们将程序的界面设置为游戏页面，并根据大作业要求中的内容设置关卡信息。
	- `on_levelButton4_clicked()`在`第四关`键被按下时被调用。它将弹出一个文件选择对话框并试图读取一个`.json`文件。若读取成功，则它将程序的界面设置为游戏页面，并根据`.json`文件中的信息设置关卡信息。
	- `on_confirmNextStepButton_clicked()`在`下一步`/`检查结果`键被按下时被调用。它将读入一行游戏页面文本框中玩家输入的信息并检查其合法性，随后执行相关操作。
	- `drawStatus()`在游戏页面更新时被调用。它将根据当前关卡目前的游戏状态，在页面上显示相关信息（如当前输入序列、目标输出序列、空地状态）。
	- `setUpBackground()`在程序界面被设置为游戏页面时被调用。它将根据当前关卡的初始信息，在页面上显示相关信息（如可用指令集、可用空地数等）。
	- `printSuccessMessage()`在关卡成功通过时被调用。它弹出一个对话框，显示当前关卡已成功完成。
	- `printFailMessage()`在关卡失败时被调用。它弹出一个对话框，显示关卡失败，并提供`重新开始`与`返回主菜单`两个选项。
	- `printErrorMessage()`在输入指令非法时被调用。它弹出一个对话框，显示关卡在当前位置出现了非法指令，并提供`重新开始`与`返回主菜单`两个选项。
	- `checkResult()`在输入的指令执行完成后被调用。它比对当前输出序列与目标序列，并相应调用`printSuccessMessage()`或`printErrorMessage()`。
	- `valid(QString)`在程序检查输入的指令时被调用。它检查当前输入的指令是否在可用指令集中，并返回结果。
	- `renderLevelButton(int)`在程序被设置为选关页面时被调用。它根据当前已通关的关卡来设置当前哪些关卡可以游玩。
- `Resources.qrc`是程序的资源文件，储存了程序的背景音乐、字体与图片等。
- `widget.ui`中存储了程序图形界面的相关设置。

## 具体实现

### 设置关卡信息

以`on_levelButton4_clicked()`为例。

```c++
void Widget::on_levelButton4_clicked()
{
    qIn.clear(), qOut.clear(), qAns.clear(), cmdSet.clear();
    vec.clear(), existVec.clear(), cmdLines.clear();
    existCurrentBlock = 0;
    currentLevel = 4;

    QString filePathName = QFileDialog::getOpenFileName(this, "打开", "./", "JSON 文件 (*.json)");
    if (filePathName.isEmpty()) {
        QMessageBox::warning(this, "警告", "已取消选择关卡！");
    } else {
        QFile openFile(filePathName);
        openFile.open(QIODevice::ReadOnly);
        QByteArray fileContents = openFile.readAll();
        openFile.close();

        QJsonObject jsonObj = QJsonDocument::fromJson(fileContents).object();

        QJsonArray jsonArray = jsonObj.value("input").toArray();

        for (const QJsonValue& element : jsonArray)
            qIn.enqueue(element.toInt());

        jsonArray = jsonObj.value("output").toArray();
        for (const QJsonValue& element : jsonArray)
            qAns.enqueue(element.toInt());

        n = jsonObj.value("vacancy").toInt();
        vec.resize(n);
        existVec.resize(n);

        jsonArray = jsonObj.value("cmd").toArray();
        for (const QJsonValue& element : jsonArray) {
            switch (element.toInt()) {
            case 0:
                cmdSet.enqueue("inbox");
                break;
            case 1:
                cmdSet.enqueue("outbox");
                break;
            case 2:
                cmdSet.enqueue("copyfrom");
                break;
            case 3:
                cmdSet.enqueue("copyto");
                break;
            case 4:
                cmdSet.enqueue("add");
                break;
            case 5:
                cmdSet.enqueue("sub");
                break;
            case 6:
                cmdSet.enqueue("jump");
                break;
            case 7:
                cmdSet.enqueue("jumpifzero");
                break;
            default:
                break;
            }
        }
        ui->stackedWidget->setCurrentIndex(3);
        setUpBackground();
    }

}
```

它所接受的`.json`文件应格式如下：

```json
{
    "input": [1, 2, 7, 7, 9, 3, 3, 3],
    "output": [7, -3],
    "vacancy": 6,
    "cmd": [0, 1, 2, 3, 4, 5]
}
```

其中`input`表示初始输入序列，`output`表示目标输出序列，`vacancy`表示可用空地数量，`cmd`表示可用指令集。

成功读取后，函数将`input`序列存入队列`qIn`中，将`output`序列存入队列`qAns`中，根据`vacancy`的值设置向量`vec`与`existVec`的大小，并根据`cmd`设置关卡的可用指令集。

最后，函数将程序界面设置为游戏页面，然后调用`setUpBackground()`函数展示关卡信息。

### 执行玩家输入的指令

代码如下：

```c++
void Widget::on_confirmNextStepButton_clicked()
{
    if (!doing) {

        QStringList tmp = ui->cmdTextEdit->toPlainText().split("\n");

        for (const QString& element : tmp) {
            if (element.size())
                cmdLines.push_back(element);
        }

        m = cmdLines.size();

        if (m == 0) { // 输入的指令为空
            printFailMessage();
            return;
        }

        currentCommand = 1;
        qOut.clear();
        ui->cmdTextEdit->setFocusPolicy(Qt::NoFocus);

        ui->currentStepLabel->setText(cmdLines[currentCommand - 1]);
        ui->confirmNextStepButton->setText("下一步");
        doing = true;
    } else {

        if (currentCommand == m + 1) {
            if (checkResult()) {
                if (currentLevel != 4)
                    level = currentLevel;
                if (level >= 1) {
                    ui->levelButton2->setDisabled(false);
                }
                if (level >= 2) {
                    ui->levelButton3->setDisabled(false);
                }
            }
            return;
        }
        int argc = cmdLines[currentCommand - 1].split(' ').size();
        QString cmd = cmdLines[currentCommand - 1].split(' ')[0];
        if (valid(cmd)) {
            if (cmd == "inbox") {
                if (argc != 1) {
                    printErrorMessage();
                    return;
                }
                if (qIn.empty()) {
                    checkResult();
                }
                currentBlock = qIn.front();
                qIn.dequeue();
                existCurrentBlock = true;
            } else if (cmd == "outbox") {
                if (existCurrentBlock == false || argc != 1) {
                    printErrorMessage();
                    return;
                }
                qOut.enqueue(currentBlock);
                existCurrentBlock = false;
            } else if (cmd == "add") {
                int x = myToInt(cmdLines[currentCommand - 1].split(' ')[1]);
                if (existCurrentBlock == false || x >= vec.size() || x < 0 || existVec[x] == false || argc != 2) {
                    printErrorMessage();
                    return;
                }
                currentBlock += vec[x];
            } else if (cmd == "sub") {
                int x = myToInt(cmdLines[currentCommand - 1].split(' ')[1]);
                if (existCurrentBlock == false || x >= vec.size() || x < 0 || existVec[x] == false || argc != 2) {
                    printErrorMessage();
                    return;
                }
                currentBlock -= vec[x];
            } else if (cmd == "copyto") {
                int x = myToInt(cmdLines[currentCommand - 1].split(' ')[1]);
                if (existCurrentBlock == false || x >= vec.size() || x < 0 || argc != 2) {
                    printErrorMessage();
                    return;
                }
                vec[x] = currentBlock;
                existVec[x] = true;
            } else if (cmd == "copyfrom") {
                int x = myToInt(cmdLines[currentCommand - 1].split(' ')[1]);
                if (x >= vec.size() || x < 0 || existVec[x] == false || argc != 2) {
                    printErrorMessage();
                    return;
                }
                currentBlock = vec[x];
                existCurrentBlock = true;
            } else if (cmd == "jump") {
                int x = myToInt(cmdLines[currentCommand - 1].split(' ')[1]);
                if (x > m || x <= 0 || argc != 2) {
                    printErrorMessage();
                    return;
                }
                currentCommand = x;
                ui->currentStepLabel->setText(cmdLines[currentCommand - 1]);
                return;
            } else if (cmd == "jumpifzero") {
                int x = myToInt(cmdLines[currentCommand - 1].split(' ')[1]);
                if (existCurrentBlock == false || x > m || x <= 0 || argc != 2) {
                    printErrorMessage();
                    return;
                }
                if (currentBlock == 0) {
                    currentCommand = x;
                    ui->currentStepLabel->setText(cmdLines[currentCommand - 1]);
                    return;
                }
            } else {
                printErrorMessage();
                return;
            }
        } else {
            printErrorMessage();
            return;
        }
        currentCommand++;
        if (currentCommand <= m)
            ui->currentStepLabel->setText(cmdLines[currentCommand - 1]);
        else {
            ui->currentStepLabel->clear();
            ui->confirmNextStepButton->setText("检查");
        }
        drawStatus();
    }
}
```

若还未读入指令（第一次点击`确认`键），函数将读入输入文本框中的全部内容，并将其分割后存入列表`cmdLines`中，随后将`确认`键的文本改为`下一步`。

若已经读入了指令，函数将依次按行执行指令，并在最后一条指令执行完成后调用`checkResult()`函数确认关卡是否成功通过。

### 判断输入的指令是否合法

```c++
int myToInt(QString str) {
    for (auto x : str) {
        if (!x.isDigit())
            return -1;
    }
    return str.toInt();
}
```

```c++
bool Widget::valid(QString test) {
    for (const QString &a : cmdSet) {
        if (a == test)
            return true;
    }
    return false;
}
```

以上的两个函数用于判断玩家的输入是否合法。`valid(Qstring)`函数用于判断输入的指令本身是否存在于可用指令集中。`myToInt(QString)`函数用于判断指令的参数是否合法。本次大作业中所有指令的参数最多只有一个，且不存在除数字外的字符（无小数点，无负号），可根据这一点进行判断。

## 界面设计

程序共有四个界面。进入游戏将显示主界面：

<div align=center> <img src="./Pictures/MainPage.png" width = 400>

通过此界面可以前往关卡选择界面，设置界面或者退出游戏。

从关卡选择界面可以前往四个关卡，或者返回主界面。

<div align=center> <img src="./Pictures/LevelPage.png" width = 400>

游戏界面显示了关卡的当前状态。玩家可以在页面中央的文本框中输入指令。

<div align=center> <img src="./Pictures/GamePage.png" width = 400>

设置界面可以调整游戏背景音乐的音量。

<div align=center> <img src="./Pictures/AboutPage.png" width = 400>

## 游戏测试

游戏可以正确执行每条指令，并能够在其出错时识别出来。

### inbox

<div align=center> <img src="./Pictures/Inbox1.png" width = 400>

<div align=center> <img src="./Pictures/Inbox2.png" width = 400>

### outbox

<div align=center> <img src="./Pictures/Outbox1.png" width = 400>

<div align=center> <img src="./Pictures/Outbox2.png" width = 400>

当前积木不存在时，程序会报错。

<div align=center> <img src="./Pictures/OutboxErr1_1.png" width = 400>

<div align=center> <img src="./Pictures/OutboxErr1_2.png" width = 400>

### add

<div align=center> <img src="./Pictures/Add1.png" width = 400>

<div align=center> <img src="./Pictures/Add2.png" width = 400>

当前积木不存在时，程序会报错。

<div align=center> <img src="./Pictures/AddErr1_1.png" width = 400>

<div align=center> <img src="./Pictures/AddErr1_2.png" width = 400>

目标空地不存在积木时，程序会报错。

<div align=center> <img src="./Pictures/AddErr2_1.png" width = 400>

<div align=center> <img src="./Pictures/AddErr2_2.png" width = 400>

### sub

<div align=center> <img src="./Pictures/Sub1.png" width = 400>

<div align=center> <img src="./Pictures/Sub2.png" width = 400>

当前积木不存在时，程序会报错。

<div align=center> <img src="./Pictures/SubErr1_1.png" width = 400>

<div align=center> <img src="./Pictures/SubErr1_2.png" width = 400>

目标空地不存在积木时，程序会报错。

<div align=center> <img src="./Pictures/SubErr2_1.png" width = 400>

<div align=center> <img src="./Pictures/SubErr2_2.png" width = 400>

### copyto

<div align=center> <img src="./Pictures/Copyto1.png" width = 400>

<div align=center> <img src="./Pictures/Copyto2.png" width = 400>

当前积木不存在时，程序会报错。

<div align=center> <img src="./Pictures/CopytoErr1_1.png" width = 400>

<div align=center> <img src="./Pictures/CopytoErr1_2.png" width = 400>

目标空地不存在时，程序会报错。

<div align=center> <img src="./Pictures/CopytoErr2_1.png" width = 400>

<div align=center> <img src="./Pictures/CopytoErr2_2.png" width = 400>

### copyfrom

<div align=center> <img src="./Pictures/Copyfrom1.png" width = 400>

<div align=center> <img src="./Pictures/Copyfrom2.png" width = 400>

目标空地没有积木时，程序会报错。

<div align=center> <img src="./Pictures/CopyfromErr1_1.png" width = 400>

<div align=center> <img src="./Pictures/CopyfromErr1_2.png" width = 400>

目标空地不存在时，程序会报错。

<div align=center> <img src="./Pictures/CopyfromErr2_1.png" width = 400>

<div align=center> <img src="./Pictures/CopyfromErr2_2.png" width = 400>

### jump

<div align=center> <img src="./Pictures/Jump1.png" width = 400>

<div align=center> <img src="./Pictures/Jump2.png" width = 400>

<div align=center> <img src="./Pictures/Jump3.png" width = 400>

目标指令不存在时，程序会报错。

<div align=center> <img src="./Pictures/JumpErr1_1.png" width = 400>

<div align=center> <img src="./Pictures/JumpErr1_2.png" width = 400>

### jumpifzero

<div align=center> <img src="./Pictures/Jumpifzero1.png" width = 400>

<div align=center> <img src="./Pictures/Jumpifzero2.png" width = 400>

<div align=center> <img src="./Pictures/Jumpifzero3.png" width = 400>

当前方块不为0时，程序不会做任何操作。

<div align=center> <img src="./Pictures/Jumpifzero4.png" width = 400>

<div align=center> <img src="./Pictures/Jumpifzero5.png" width = 400>

目标指令不存在时，程序会报错。

<div align=center> <img src="./Pictures/JumpifzeroErr1_1.png" width = 400>

<div align=center> <img src="./Pictures/JumpifzeroErr1_2.png" width = 400>

当前积木不存在时，程序会报错。

<div align=center> <img src="./Pictures/JumpifzeroErr2_1.png" width = 400>

<div align=center> <img src="./Pictures/JumpifzeroErr2_2.png" width = 400>

### 其他异常情况

出现未定义指令

<div align=center> <img src="./Pictures/Err1_1.png" width = 400>

<div align=center> <img src="./Pictures/Err1_2.png" width = 400>

指令参数错误（为负数）

<div align=center> <img src="./Pictures/Err2_1.png" width = 400>

<div align=center> <img src="./Pictures/Err2_2.png" width = 400>

指令参数错误（不为整数）

<div align=center> <img src="./Pictures/Err3_1.png" width = 400>

<div align=center> <img src="./Pictures/Err3_2.png" width = 400>

指令参数错误（参数数量过多）

<div align=center> <img src="./Pictures/Err4_1.png" width = 400>

<div align=center> <img src="./Pictures/Err4_2.png" width = 400>

